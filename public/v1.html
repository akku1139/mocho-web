<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Mocho SRU - Browser Inference</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.all.min.js"></script>
    <style>
        body { font-family: sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; line-height: 1.6; }
        textarea { width: 100%; padding: 10px; font-size: 1rem; margin-bottom: 10px; }
        #output { background: #f4f4f4; padding: 15px; border-radius: 5px; min-height: 100px; white-space: pre-wrap; border: 1px solid #ddd; }
        .controls { margin-bottom: 20px; }
        button { padding: 10px 20px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; }
        button:disabled { background: #ccc; }
        .status { font-size: 0.9rem; color: #666; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Mocho SRU</h1>
    <div id="status" class="status">ライブラリを読み込み中...</div>
    
    <div class="controls">
        <label>入力テキスト:</label>
        <textarea id="inputText" rows="3">日本の歴史において、</textarea>
        <button id="generateBtn" disabled>生成開始</button>
    </div>

    <div id="output">ここに結果が表示されます...</div>

    <script type="module">
        // Transformers.js からトークナイザーのみをインポート
        import { AutoTokenizer } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers';

        const N_LAYER = 6;
        const N_EMBD = 512;
        const MODEL_PATH = 'https://github.com/akku1139/mocho/releases/download/v1-l6-e512-1/mocho.onnx';
        const TOKENIZER_PATH = 'https://github.com/akku1139/mocho/releases/download/v1-l6-e512-1/'; // フォルダを指定すると自動で tokenizer.json を探します

        let session;
        let tokenizer;

        async function init() {
            try {
                const statusEl = document.getElementById('status');
                
                // 1. トークナイザーのロード
                statusEl.innerText = "トークナイザーをロード中...";
                tokenizer = await AutoTokenizer.from_pretrained(TOKENIZER_PATH);

                // 2. ONNX セッションの初期化
                statusEl.innerText = "ONNXモデルをロード中 (WebGPUを試行)...";
                // WebGPUが利用可能なら優先して使用
                session = await ort.InferenceSession.create(MODEL_PATH, {
                    executionProviders: ['webgpu', 'wasm'],
                    graphOptimizationLevel: 'all'
                });

                statusEl.innerText = `準備完了 (Backend: ${session.handler.constructor.name})`;
                document.getElementById('generateBtn').disabled = false;
            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = "エラー: " + e.message;
            }
        }

        async function generate() {
            const contextStr = "初期化した"; // 必要に応じて入力欄を追加してください
            const inputStr = document.getElementById('inputText').value; // 例: "ケッカハザンネンナモノデアッタ"
            const outputEl = document.getElementById('output');
            const btn = document.getElementById('generateBtn');
            
            btn.disabled = true;
            outputEl.innerText = "";
        
            try {
                // --- 1. 特殊トークンのID取得とプロンプト構成 ---
                // Python: [tokenizer.token_to_id("<s>")] + tokenizer.encode(left_context).ids + ...
                
                const s_id = tokenizer.model.convert_tokens_to_ids(['<s>'])[0];
                const input_marker_id = tokenizer.model.convert_tokens_to_ids(['[INPUT]'])[0];
                const output_marker_id = tokenizer.model.convert_tokens_to_ids(['[OUTPUT]'])[0];
                const eos_id = tokenizer.model.convert_tokens_to_ids(['</s>'])[0];
        
                const context_ids = (await tokenizer(contextStr, { add_special_tokens: false })).input_ids.data;
                const input_ids = (await tokenizer(inputStr, { add_special_tokens: false })).input_ids.data;
        
                // シーケンス結合: <s> + context + [INPUT] + input + [OUTPUT]
                let currentIds = [
                    BigInt(s_id),
                    ...Array.from(context_ids),
                    BigInt(input_marker_id),
                    ...Array.from(input_ids),
                    BigInt(output_marker_id)
                ];
        
                // --- 2. 初期隠れ状態（States）の作成 ---
                let states = {};
                for (let i = 0; i < N_LAYER; i++) {
                    states[`state_in_${i}`] = new ort.Tensor('float32', new Float32Array(N_EMBD), [1, N_EMBD]);
                }
        
                // --- 3. 推論ループ ---
                // 初回（Prefill）: 組み立てた全トークンを入力
                // 2回目以降（Decode）: 直前の1トークンのみを入力
                let isFirstStep = true;
        
                for (let i = 0; i < 100; i++) {
                    const seqLen = currentIds.length;
                    const inputTensor = new ort.Tensor('int64', BigInt64Array.from(currentIds), [seqLen, 1]);
                    
                    const feeds = {
                        idx: inputTensor,
                        ...states
                    };
        
                    const results = await session.run(feeds);
        
                    // Logitsから次のトークンを選択 (末尾のベクトルを取得)
                    const logits = results.logits.data;
                    const vocabSize = results.logits.dims[2];
                    const lastTokenLogits = logits.slice(-vocabSize);
                    
                    // Temperature 0.2 相当の Greedy（最大値選択）
                    const nextToken = argmax(lastTokenLogits);
        
                    if (nextToken === eos_id) break;
        
                    // 表示更新
                    const decoded = tokenizer.decode([nextToken]);
                    outputEl.innerText += decoded;
        
                    // Statesの更新
                    for (let j = 0; j < N_LAYER; j++) {
                        states[`state_in_${j}`] = results[`state_out_${j}`];
                    }
        
                    // 次の入力準備: 1トークンのみ
                    currentIds = [BigInt(nextToken)];
                    isFirstStep = false;
        
                    // UIのフリーズ防止
                    await new Promise(r => setTimeout(r, 0));
                }
            } catch (e) {
                console.error(e);
                outputEl.innerText += "\n[Error]: " + e.message;
            }
            btn.disabled = false;
        }
      
        function argmax(arr) {
            let max = -Infinity;
            let index = 0;
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] > max) { max = arr[i]; index = i; }
            }
            return index;
        }

        document.getElementById('generateBtn').onclick = generate;
        init();
    </script>
</body>
</html>
