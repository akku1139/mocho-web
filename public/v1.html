<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Mocho SRU - Browser Inference</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.all.min.js"></script>
    <style>
        body { font-family: sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; background-color: #f9f9f9; }
        .card { background: white; padding: 2rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .field { margin-bottom: 1.5rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: bold; }
        input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box; }
        button { background: #007bff; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; }
        button:disabled { background: #ccc; }
        #output { margin-top: 1.5rem; padding: 1rem; background: #f1f1f1; border-radius: 6px; min-height: 50px; white-space: pre-wrap; border-left: 4px solid #007bff; font-family: monospace; }
        .status { font-size: 0.85rem; color: #888; margin-top: 1rem; }
    </style>
</head>
<body>

<div class="card">
    <h1>Mocho SRU Browser</h1>
    
    <div class="field">
        <label>左側文脈:</label>
        <input type="text" id="leftContext" value="初期化した">
    </div>

    <div class="field">
        <label>入力 (カタカナ):</label>
        <input type="text" id="inputText" value="ケッカハザンネンナモノデアッタ">
    </div>

    <button id="generateBtn" disabled>ロード中...</button>

    <div id="output">モデルを読み込んでいます...</div>
    <div id="status" class="status"></div>
</div>

<script type="module">
    import { AutoTokenizer, env } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers';

    // --- 設定 ---
    ort.env.debug = true;
    ort.env.logLevel = 'verbose';
    // ort.env.wasm.simd = false;
    env.remoteHost = 'https://raw.githubusercontent.com/akku1139/mocho/refs/heads/';
    env.remotePathTemplate = '{model}/model/tokenizer';
    // GitHub Releases 等の直リンクを指定
    const MODEL_URL = '/proxy/gh/akku1139/mocho/releases/download/v1-l6-e512-1/mocho.onnx';
    const TOKENIZER_JSON_URL = 'tokenizer.json';
    
    const N_LAYER = 6;
    const N_EMBD = 512;

    let session;
    let tokenizer;

    const btn = document.getElementById('generateBtn');
    const statusEl = document.getElementById('status');
    const outputEl = document.getElementById('output');

    async function init() {
        try {
            statusEl.innerText = "トークナイザーをロード中...";
            // remoteURLを指定することでHF Hubを介さず直接ファイルを読み込む
            tokenizer = await AutoTokenizer.from_pretrained('v1', {
                config: { model_type: 'gpt2' }, // 汎用的な設定を指定
                custom_files: { 'tokenizer.json': TOKENIZER_JSON_URL }
            });

            statusEl.innerText = "ONNXモデルをロード中...";
            session = await ort.InferenceSession.create(MODEL_URL, {
                executionProviders: ['wasm'], // WebGPUが不安定な場合はまずWASMで確認
            });

            statusEl.innerText = `準備完了`;
            btn.innerText = "生成実行";
            btn.disabled = false;
            outputEl.innerText = "ボタンを押すと生成を開始します。";
        } catch (e) {
            console.error(e);
            statusEl.innerText = "エラー: " + e.message;
        }
    }

    async function generate() {
        const leftCtx = document.getElementById('leftContext').value;
        const inputStr = document.getElementById('inputText').value;
        
        btn.disabled = true;
        outputEl.innerText = "推論中...";
    
        try {
            // --- tokenizer.json に基づく正しいID指定 ---
            const S_ID = 2;          // <s>
            const CONTEXT_ID = 6000; // [CONTEXT]
            const INPUT_ID = 6001;   // [INPUT]
            const OUTPUT_ID = 6002;  // [OUTPUT]
            const EOS_ID = 3;        // </s>
    
            const left_res = await tokenizer(leftCtx, { add_special_tokens: false });
            const in_res = await tokenizer(inputStr, { add_special_tokens: false });
            
            const left_ids = Array.from(left_res.input_ids.data);
            const in_ids = Array.from(in_res.input_ids.data);
    
            // プロンプト全体の組み立て
            const allPromptIds = [
                S_ID, 
                CONTEXT_ID, 
                ...left_ids, 
                INPUT_ID, 
                ...in_ids, 
                OUTPUT_ID
            ];
            
            // 状態の初期化 [Layers, Batch, Dim]
            let states = new ort.Tensor('float32', new Float32Array(N_LAYER * 1 * N_EMBD), [N_LAYER, 1, N_EMBD]);
            let lastLogits = null;
    
            // 【重要】Prefill（最初のプロンプト入力）も1トークンずつ実行する
            // これをしないと ONNX 内部のループがバグり、「として」地獄になります
            outputEl.innerText = ""; 
            for (const tid of allPromptIds) {
                const idxTensor = new ort.Tensor('int64', BigInt64Array.from([BigInt(tid)]), [1, 1]);
                const feeds = { idx: idxTensor, c_states: states };
                const results = await session.run(feeds);
                
                states = results.new_states;
                lastLogits = results.logits.data; 
            }
    
            // --- 生成ループ (出力トークンの生成) ---
            for (let step = 0; step < 100; step++) {
                const vocabSize = 6003; // vocab_size
                const currentLogits = lastLogits.slice(-vocabSize);
    
                // Argmax で次のトークンを選択
                let nextToken = 0;
                let maxLogit = -Infinity;
                for (let i = 0; i < vocabSize; i++) {
                    if (currentLogits[i] > maxLogit) {
                        maxLogit = currentLogits[i];
                        nextToken = i;
                    }
                }
    
                if (nextToken === EOS_ID) break;
    
                // デコード
                const word = tokenizer.decode([nextToken]);
                outputEl.innerText += word;
    
                // 次のトークンを1つだけ入力して状態を更新
                const idxTensor = new ort.Tensor('int64', BigInt64Array.from([BigInt(nextToken)]), [1, 1]);
                const feeds = { idx: idxTensor, c_states: states };
                const results = await session.run(feeds);
    
                states = results.new_states;
                lastLogits = results.logits.data;
    
                await new Promise(r => setTimeout(r, 0));
            }
    
        } catch (e) {
            console.error(e);
            outputEl.innerText += "\n[Error]: " + e.message;
        }
        btn.disabled = false;
    }

    btn.onclick = generate;
    init();
</script>

</body>
</html>
